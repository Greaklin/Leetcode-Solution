//记录一下，今天没有挑战不使用字符串分离整形各位成功，明日再来继续！
//2022.01.04
//回文数，思路如下：
//思路一：以10进制整形除法分离计算
//思路二：以2进制计算，回文数的2进制有什么特点？
//比如11，二进制中为1011；22，二进制中为0001 0110；33，二进制中为0010 0001；44，二进制为0010 1100
//55，二进制为0011 0111；
//好像没规律，位数高了之后二进制更没有了，今天先10进制解决
//将各个位数进行拆分后得到最终的
//估计最后会有超长的回文数，2的32次方大小的回文数emm，2的30次方大概是百万，10进制为6位数，得进行实时比较
//难点在于怎么分离出各个位置的数
//如x=10086，则x/10000=1，x%1000=0086 x-x%level低一级，再除以本级可以得到从高到低本位的数
//从低到高本位的数，则直接与，哦哦，直接与就可以了
//1的2进制为0001，10的2进制为1010，100的2进制为0110 0100。。。直接对其按位与后除本位即可得到
//如果用字符串记录各个位则设置一个字符转换函数转换成字符串数组就可以了，然后各个位置互相比较

bool isPalindrome(int x){
    if(x<0)//如果输入小于0则直接返回失败
    return false;
    //首先得判断x多大
    int level = 1;//记录输入x的数量级
    int fz = 1;
    while((int)(x/level)) level*=10;//利用int类型向0取整特性，得到x的数量级，虽然用的除法有点难顶
    level = level/10;//恢复x的数量级
    while((x/level)<=(x/fz)){//当比较过中位数之后则停止
        if(((x&level)/level)!=((x&fz)/fz))//****************该步的判断是核心难点,今天此处写错了，100与121是96不是100,错在了与运算。与运算只能检测1001这类回文数
        return false;
        level /= 10;
        fz *=10;
    }  
    return true;
}
