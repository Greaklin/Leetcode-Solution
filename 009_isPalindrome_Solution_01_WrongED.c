Solution01

WrongED
//记录一下，今天没有挑战不使用字符串分离整形各位成功，明日再来继续！
//2022.01.04
//回文数，思路如下：
//思路一：以10进制整形除法分离计算
//思路二：以2进制计算，回文数的2进制有什么特点？
//比如11，二进制中为1011；22，二进制中为0001 0110；33，二进制中为0010 0001；44，二进制为0010 1100
//55，二进制为0011 0111；
//好像没规律，位数高了之后二进制更没有了，今天先10进制解决
//将各个位数进行拆分后得到最终的
//估计最后会有超长的回文数，2的32次方大小的回文数emm，2的30次方大概是百万，10进制为6位数，得进行实时比较
//难点在于怎么分离出各个位置的数
//如x=10086，则x/10000=1，x%1000=0086 x-x%level低一级，再除以本级可以得到从高到低本位的数
//从低到高本位的数，则直接与，哦哦，直接与就可以了
//1的2进制为0001，10的2进制为1010，100的2进制为0110 0100。。。直接对其按位与后除本位即可得到
//如果用字符串记录各个位则设置一个字符转换函数转换成字符串数组就可以了，然后各个位置互相比较

bool isPalindrome(int x){
    if(x<0)//如果输入小于0则直接返回失败
    return false;
    //首先得判断x多大
    int level = 1;//记录输入x的数量级
    int fz = 1;
    while((int)(x/level)) level*=10;//利用int类型向0取整特性，得到x的数量级，虽然用的除法有点难顶
    level = level/10;//恢复x的数量级
    while((x/level)<=(x/fz)){//当比较过中位数之后则停止
        if(((x&level)/level)!=((x&fz)/fz))//****************该步的判断是核心难点,今天此处写错了，100与121是96不是100,错在了与运算。与运算只能检测1001这类回文数
        return false;
        level /= 10;
        fz *=10;
    }  
    return true;
}

CompleteED
//2022.01.05
//今天在昨天的基础上进行了改进，成功通过，测试用例11510个执行用时4ms，击败94.39%，关键点在于15行位置的判断还有10行需要用long，否则当x足够大时level将会溢出，使用long保证运算时潜在使用的是整形

bool isPalindrome(int x){
    if(x<0)//如果输入小于0则直接返回失败
    return false;
    if(x == 0)
    return true;
    //首先得判断x多大
    long level = 1;//记录输入x的数量级（不用long可能level会溢出）
    long fz = 1;
    while((int)(x/level)) level*=10;//利用int类型向0取整特性，得到x的数量级，虽然用的除法有点难顶
    level = level/10;//恢复x的数量级
    while((x/level)<(x/fz)){//当比较过中位数之后则停止,//注意，此处x不能等于0！不然Leetcode会报错
        if((x/level)!=(x%(10*fz)/fz))//该步的判断是核心难点，x/level为当前当前数量级，但每次x的个位数都需要单独拿出来，单独拿出x的某个位需要用(x%(10*fz)/fz)表达式结合19行的变化，先x取余比其高一位的再除
        return false;
        x = x%level;//去掉x的最高位数，直接取余数
        level /= 10;
        fz *=10;
    }
    return true;
}


OffiialSolution
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//2022年01月12日，C++官方解答注释解析
class Solution {
public:
    bool isPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {//反转后半段的数字，最后与前半段数字进行比较
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;//x存储原去除最低反转位的数字
        }

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber / 10;
    }
};
